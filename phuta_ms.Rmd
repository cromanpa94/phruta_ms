---
output: 
  stevetemplates::article:
    fig_caption: true
#bibliography: master.bib
biblio-style: apsr
title: "phruta: scrapping genbank and assembling phylogenetic trees"
thanks: "Replication files are available on the author's Github account (http://github.com/cromanpa). **Current version**: `r format(Sys.time(), '%B %d, %Y')`; **Corresponding author**: cromanpa94@arizona.edu."
author:
- name: Cristian Rom√°n-Palacios
  affiliation: School of Information, University of Arizona, Tucson, Arizona 85721, USA. ORCiD`:` 0000-0003-1696-4886
abstract: "Current methodological practices for assembling phylogenetic trees often recur to sequence data stored in GenBank. However, understanding molecular and taxonomic availability in GenBank is generally not very straightforward. For instance, the genetic makeup of datasets available in GenBank can strongly differ between genera even within the same family. Similarly, the taxonomic information associated with sequence data in GenBank can be outdated, relative to other databases that mainly focus on the taxonomic side. phruta, a newly developed R package, is designed to improve the user experience and access to information to genetic data stored in GenBank. By using phruta, users are able to (1) quantitatively explore the molecular makeup of particular clades with information in GenBank, (2) assemble curated multi-gene molecular datasets with retrieved and local sequences, and (3) run basic phylogenetic talks, all within R. The structure of the functions implemented in phruta, designed as a workflow, aim to allow users to assemble simple workflows for particular talks, which are in turn expected to increase reproducibility when assembling phylogenies. This paper provides a brief overview on the performance and workflow associated with phruta. "
keywords: "R package, Phylogenetics, Reproducibility, Workflow"
date: "`r format(Sys.time(), '%B %d, %Y')`"
geometry: margin=1in
fontfamily: mathpazo
fontsize: 11pt
spacing: double
endnote: no
---

```{r setup, include=FALSE}
library(knitr)
library(kableExtra)
library(benchmarkme)
library(ggtree)
knitr::opts_chunk$set(cache = TRUE,
                      message = FALSE, 
                      warning = FALSE,
                      fig.path = 'figs/',
                      cache.path = '_cache/',
                      fig.process = function(x) {
                      x2 = sub('-\\d+([.][a-z]+)$', '\\1', x)
                      if (file.rename(x, x2)) x2 else x
                      })
```

## Background

## The `phruta` `R` package

The `phruta` package is designed to simplify the basic phylogenetic pipeline in `R`. `phruta` is expected to allow scientists from different backgrounds to assemble molecular databases or phylogenies for particular taxa with as minimal complexity and maximal reproducibility as possible. All the code in `phruta` is run within the same software (`R`) and data from intermediate steps are either stored to the environment or can be exported locally to different folders. In general, `phruta` is able to (1) find potentially (phylogenetically) relevant gene regions for a given set of taxa based on GenBank, (2) retrieve gene sequences and curate taxonomic information from the same database, (3) combine downloaded and local gene sequences, and (4) perform sequence alignment, phylogenetic inference, and basic tree dating tasks.

## Alternatives to phruta

Similar functionalities for assembling curated molecular datasets for phylogenetic analyses can be found in [`phylotaR`](https://github.com/ropensci/phylotaR) and [SuperCRUNCH](https://github.com/dportik/SuperCRUNCH). However, `phylotaR` is limited to downloading and curating sequences (e.g. it does not align sequences). Similarly, `SuperCRUNCH` only curates sequences that are already stored locally. In fact, `phruta` is closer to [`SUPERSMART`](https://academic.oup.com/sysbio/article/66/2/152/2418028) and the associated `R` workflow [`SUPERSMARTR`](https://github.com/AntonelliLab/supersmartR). However, most of the applications in the different packages that are part of `SUPERSMARTR` are simplified in `phruta`. Standalone applications that might resemble `phruta` could include `MEGA` and geneious. However, analyses in these two alternatives are either poorly reproducible (e.g. `MEGA`) or not all the functions are freely available  to everyone (e.g. geneious has a paid version). 

## `phruta` in a nutshell

The current release of `phruta` includes a set of eight major functions. Running all eight major functions in `phruta` results in a time-calibrated phylogeny. However, users interested in using their own files at any stage can run each function independently. Note that all the functions for which their primary output are sequences (aligned or unaligned) are listed under `sq.*`. All the files that output phylogenies (time-calibrated or not) are listed under `tree.*`.

-   First, the distribution of gene sampled for a given organism or set of taxa can be explored using the `acc.gene.sampling` function. This function will return a table that summarizes either the distribution of genes sampled for the search term in general or specifically across species.

-   Second, given a list of target organisms, users can retrieve a list of accession numbers that are relevant to their search using `acc.table.retrieve()`. Instead of directly downloading sequences from genbank (see `sq.retrieve.direct()` below), retrieving accession numbers allow users to have more control over the sequences that are being used in the analyses. Note that users can also curate the content of the dataset obtained using `sq.retrieve.direct()`.

-   Third, users should download gene sequences. Sequences can be download using the `sq.retrieve.indirect()` from the accession numbers retrieved before using the `acc.table.retrieve()` function. This is the preferred option within `phruta`. Additionally, users can directly download gene sequences using the `sq.retrieve.direct()` function. Both `sq.retrieve.indirect()` and `sq.retrieve.direct()` functions save gene sequences in `fasta` files that will be located in a new directory named `0.Sequences`.

-   Fourth, `sq.add()` allows users to include local sequences to those retrieved from genbank in the previous step. This function saves all the resulting `fasta` files in two directories, combined sequences in `0.Sequences` and local sequences in `0.AdditionalSequences` (originally downloaded sequences are moved to `0.0.OriginalDownloaded` at this step). Note that `sq.add()` is optional.

-   Fifth, the `sq.curate()` function filters out unreliable sequences based on information listed in genbank (e.g. `PREDICTED`) and on taxonomic information provided by the user. Specifically, this function retrieves taxonomic information from the Global Biodiversity Information Facility (GBIF) database's taxonomic backbone (see alternatives in the advanced vignette to `phruta`). If a given species belongs to a non-target group, this species is dropped from the analyses. This function automatically corrects taxonomy and renames sequences.

-   Sixth, `sq.aln()` performs multiple sequence alignment on `fasta` files. Currently, `phruta` uses the [`DECIPHER` R package](http://www2.decipher.codes/), here. This package allows for adjusting sequence orientation and masking (removing ambiguous sites).

-   Seventh, the `tree.raxml()` function allows users to perform tree inference under `RAxML` for sequences in a given folder. This is a wrapper to `ips::raxml()` and each of the arguments can be customized. The current release of `phruta` can manage both partitioned and unpartitioned analyses. Starting and constrained trees are allowed.

-   Eight, `tree.dating()` enables users to perform time-calibrations of a given phylogeny using `geiger::congruify.phylo()`. `phruta` includes a basic set of comprehensively sampled, time-calibrated phylogenies that are used to extract secondary calibrations for the target phylogeny. Note that sampling in those phylogenies can be examined using `data(SW.phruta)`. Please make sure you have at least **two** groups in common with each of the phylogenies. Similarly, users can choose to run either `PATHd-8` or `treePL`.

## Assembling a molecular dataset for target taxa in phruta

Let's learn how `phruta` works by assembling a molecular dataset at the species level for a few bird clades. For this tutorial, we will focus on assembling a phylogeny for the new world Quails (family Odontophoridae), with nearly 34 extant species classified in 10 genera (\@ref(fig:quail)). We will use the Phasianidae as an outgroup. Within this clade, we will particularly focus on the genus **Polyplectron** with 8 extant species. Luckily, we will be able to compare how similar is the resulting tree for the Odontophoridae relative to pushed phylogenies (Crowe et al. 2006a, b; Cohen et al. 2012; Hosner et al. 2015). You can explore the functionalities of `phruta` using other taxonomic groups of your choice.

```{r, eval = TRUE, warning = TRUE, message = TRUE, progress = TRUE}
library(phruta)
```

```{r setup2, eval = TRUE, echo=FALSE, include = FALSE}
assign(".testMode", TRUE, envir = phruta:::pkg.env)
start_time <- Sys.time()
```

So far, we have decided the taxonomic makeup of our analyses. From this point, we could simply check the genetic sampling of previous studies and search for those genes in GenBank for the target taxa (Crowe et al. 2006a, b; Cohen et al. 2012; Hosner et al. 2015). For instance, [review sampling in each of those]. We could use these gene names to assemble a molecular dataset for the Odontophoridae and **Polyplectron** in `phruta`. Alternatively, we could use `phruta` to figure out what genes are well sampled in GenBank for both the ingroup and outgroup. We will do the latter in this paper. For this, we will use the `gene.sampling.retrieve()` function in `phruta`. The resulting `data.frame`, named `gs.seqs` in this guide, will contain the list of full names for genes sampled in GenBank for the target taxa.

```{r results = 'hide'}
gs.seqs <- gene.sampling.retrieve(organism = c("Odontophoridae", "Polyplectron"), 
                                  speciesSampling = TRUE)
```

For the search terms, `phruta` was able to retrieve the names for `r nrow(gs.seqs)` gene regions from GenBank. The frequency estimates per gene are based on inter-specific sampling (\@ref(tab:topGenes)). Note that the `gene.sampling.retrieve()` function provides an estimate of the number of species in GenBank that match the taxonomic criteria of the search term and that have sequences for a given gene region. However, this estimate is only as good as the annotations for genes deposited in GenBank.

From this point, we will generate a preliminary summary of the accession numbers retrieved for the combination of target taxa and gene regions. I call it preliminary because not all these accession numbers are expected to be in the final molecular dataset. For instance, some sequences could be labeled in GenBank under different species, which turn out being synonyms.

We will now assemble a species-level summary of accession numbers using the `acc.table.retrieve()` function (i.e. `speciesLevel = TRUE` argument). For simplicity, this tutorial will focus on analyzing gene regions that are sampled in \>20% of the species (`targetGenes` data.frame). The `acc.table` object created below is a `data.frame` object that will be later used to download the relevant gene sequences from GenBank (\@ref(tab:AccN)). 

```{r  results = 'hide'}
targetGenes <- gs.seqs[gs.seqs$PercentOfSampledSpecies > 20,]
acc.table <- acc.table.retrieve(
            clades  = "Odontophoridae",
            species = "Polyplectron",
            genes = targetGenes$Gene,
            speciesLevel = TRUE
          )
```

Since we're going to retrieve sequences from GenBank using an existing preliminary accession numbers table, we will use the `sq.retrieve.indirect()` function in `phruta`. Please note that there are two versions of `sq.retrieve.*` in `phruta` . The one that we're using in this guide, `sq.retrieve.indirect()`, retrieves sequences "indirectly" because it requieres a table of accession numbers (see the `acc.table.retrieve()` function above). I present the information in this vignette using `sq.retrieve.indirect()` instead of `sq.retrieve.direct()` because `sq.retrieve.indirect()` is more flexible. Specifically, `sq.retrieve.indirect()` allows for correcting issues *prior* to downloading/retrieving the sequences. For instance, you can add new sequences, species, populations to the resulting `data.frame` from `acc.table.retrieve()`. Additionally, you could even manually assemble your own dataset of accession numbers to be retrieved using `sq.retrieve.indirect()`. Instead, `sq.retrieve.direct()` does its best to directly retrieve GenBank sequences for a target set of taxa and set of gene regions. In short, you should be able to catch errors using `sq.retrieve.indirect()` but mistakes will be harder to spot and fix if you're using `sq.retrieve.direct()`. 

We still need to retrieve all the sequences from the accessions table generated using `acc.table`. Note that since we have specified `download.sqs = FALSE` in `sq.retrieve.indirect`, the sequences retrieved from GenBank are returned in a list that is stored in your global environment. If we decide to download the sequences to our working directory using `download.sqs = TRUE`, `phruta` will write all the resulting `fasta` files into a newly created folder `0.Sequences` located in our working directory. 

```{r results = 'hide'}
sqs.downloaded <- sq.retrieve.indirect(acc.table = acc.table, download.sqs = FALSE)
```

We are now going to make sure that we include only sequences that are reliable and from species that we are actually interested in analyzing. We are going to use the `sq.curate()` function for this. We will provide a list of taxonomic names to filter out incorrect sequences (`filterTaxonomicCriteria` argument). For instance, we could simply provide a vector of the genera that we are interested in analyzing. This vector must have a length of `1`, with all the target genera being separated with `|` (e.g. `"Callipepla|Colinus|Dendrortyx"` if we were interested in only those three genera). For now, we will assume that all of the species we downloaded are relevant to the analyses (i.e. `filterTaxonomicCriteria = [AZ]`). Finally, since we are not downloading anything to our working directory, we need to pass our downloaded sequences (`sqs.downloaded` object generated above using the `sq.retrieve.indirect()` function) to the `sqs.object` argument in `sq.curate()`.

```{r results = 'hide'}
sqs.curated <- sq.curate(filterTaxonomicCriteria = '[AZ]',
                         kingdom = 'animals', 
                         sqs.object = sqs.downloaded,
                         removeOutliers = FALSE)
```

Running the `sq.curate()` function will create an object of class `list` including (1) the curated sequences with original names, (2) the curated sequences with species-level names (`renamed_*` prefix), (3) the accession numbers table (`AccessionTable`; \@ref(tab:tw)), and (4) a summary of taxonomic information for all the species sampled in the files (\@ref(tab:tw2), \@ref(tab:tw3)). From here, we will simply align the sequences that we just curated. For this, we will use `sq.aln()` with default parameters. We're again passing the output from `sq.curate()`, `sqs.curated`, using the `sqs.object` argument in `sq.aln()`.

```{r results = 'hide'}
sqs.aln <- sq.aln(sqs.object = sqs.curated)
```

The resulting multiple sequence alignments will be saved to the `sqs.aln` object, a list of sequence alignments. For each of the gene regions, we will have access to the original alignment (`Aln.Original`), the masked one (`Aln.Masked`), and information on the masking process. The raw and masked alignments are presented in \@ref(fig:alnraw) and \@ref(fig:alncur), respectively.

```{r echo = FALSE}
library(ape)
pdf("figs/UF.Raw.pdf", width = 8, height = 8)
par(mfrow = c(ceiling(length(sqs.aln)/2),2))
for (i in seq_along(sqs.aln)) {
  if (!is.null(sqs.aln[[i]]$Aln.Original)){
  image(sqs.aln[[i]]$Aln.Original,
        main = names(sqs.aln)[i], 
        show.labels = FALSE, 
        xlab = "Position",
        ylab = "Species", 
        legend = FALSE)
  }
}
sv <- dev.off()
```


```{r echo = FALSE}
pdf("figs/UF.Cur.pdf", width = 8, height = 8)
par(mfrow = c(ceiling(length(sqs.aln)/2),2))
for (i in seq_along(sqs.aln)) {
  if(!is.null(sqs.aln[[i]]$Aln.Masked)) {
  image(sqs.aln[[i]]$Aln.Masked, 
        main = names(sqs.aln)[i], 
        show.labels = FALSE, 
        xlab = "Position",
        ylab = "Species", legend = FALSE
        )
  }
}
sv <- dev.off()
```

```{r echo = FALSE}
end_time <- Sys.time()
```

In total, the lines of code in this section took `r round(end_time-start_time)` minutes to run in my local machine (RAM: `r get_ram()`, CPU: `r get_cpu()$model_name`, cores: `r get_cpu()$no_of_cores`, plataform: `r get_r_version()$platform`, R: `r get_r_version()$version.string`). 


## Basic phylogenetics with phruta

### Phylogenetic inference with `phruta` and `RAxML`

Phylogenetic inference is conducted using the `tree.raxml()` function. To use this function, we will necessarily have to save our folders locally. We will follow the same folder structure as if we were exporting everything locally ([NEED FIGURE]). Specifically, our sequence alignments are going to be located in `2.Alignments` and we will exclusively focus on the masked ones.


```{r message=FALSE, warning=FALSE}
dir.create("2.Alignments")
lapply(seq_along(sqs.aln), function(x){
  ape::write.FASTA(sqs.aln[[x]]$Aln.Masked, 
                   file = paste0(
                     "2.Alignments/Masked_", names(sqs.aln)[x], ".fasta"
                     )
                   )
})
```

We are now ready to run RAxML with our local sequences. Note that in `tree.raxml()`, we need to indicate where the aligned sequences are located (`folder` argument), the patterns of the files in the same folder (`FilePatterns` argument; "`Masked_`" in our case), and the total of boostrap replicates. The `outgroup` argument is optional but since we are interested in calibrating our tree, we will define it (i.e. species in __Polyplectron__).


```{r message=FALSE, warning=FALSE}
outgroup <- sqs.curated$Taxonomy[sqs.curated$Taxonomy$genus == 'Polyplectron',]

tree.raxml(folder = '2.Alignments', 
           FilePatterns = 'Masked_', 
           raxml_exec = 'raxmlHPC', 
           Bootstrap = 100,
           outgroup = paste(outgroup$species_names, collapse = ",")
           )
```

The trees are saved in `3.Phylogeny`. Likely, the bipartitions tree, "RAxML_bipartitions.phruta", is the most relevant. `3.Phylogeny` also includes additional `RAxML`-related input and output files. Below is the resulting phylogeny from these analyses. The resulting tree is presented in \@ref(fig:raxmlphylo).


```{r timetreePlot, message=FALSE, warning=FALSE, include = FALSE}
library(phytools)
raxmlTree <- read.tree("3.Phylogeny/RAxML_bipartitions.phruta")
raxmlTree$root.edge <- 0.01
raxmlTree <- rootedge.to.singleton(raxmlTree)

pdf("figs/raxml_ingroup.pdf", width = 8, height = 8)
plotTree(ladderize(raxmlTree, right = FALSE))
nodelabels(text = raxmlTree$node.label,
           node = 1:raxmlTree$Nnode + Ntip(raxmlTree),
           frame = "none", 
           adj = c(1.1, -0.4)
           )
dev.off()
```


### Tree dating in `phruta`

Finally, let's perform tree dating in our phylogeny using secondary calibrations extracted from [Scholl and Wiens (2016)](https://royalsocietypublishing.org/doi/pdf/10.1098/rspb.2016.1334). I am only using this study because it has a large phylogeny but I expect to replace it in the near future. Note that `tree.dating()` requieres the user to specify where the `1.Taxonomy.csv` file is. This file is created automatically when sequences are curated using `sq.curate()` and results are exported to your local repository. However, since we were keeping results in the environment, we will have to export it before we can move forward.

```{r message=FALSE, warning=FALSE}
dir.create("1.CuratedSequences")
write.csv(sqs.curated$Taxonomy, '1.CuratedSequences/1.Taxonomy.csv')
```

Tree dating is performed using the `tree.dating()` function in `phruta`. We have to provide the name of the folder containing the `1.Taxonomy.csv` file created in `sq.curate()`. We also have to indicate the name of the folder containing the `RAxML_bipartitions.phruta` file. We will scale our phylogeny using `treePL`. 

```{r message=FALSE, warning=FALSE}
tree.dating(taxonomyFolder = "1.CuratedSequences", 
            phylogenyFolder = "3.Phylogeny", 
            scale = 'treePL')
```

```{r timetree, include=FALSE}
library(strap)
calTree <- read.tree("4.Timetree/family-levelCalibration.tre")
calTree$root.edge <- 1
calTree2 <- calTree
calTree2$root.time <- max(nodeHeights(calTree2))

#Need to adjust margins
pdf("figs/phylo_ingroup.pdf", width = 8, height = 8)
geoscalePhylo(tree = ladderize(calTree2,right = FALSE), 
              units = c("Epoch", "Age"), 
              boxes = "Epoch",   
              cex.tip = 0.7, 
              cex.age = 0.7, 
              cex.ts = 0.7, 
              label.offset = 0, 
              x.lim = c(-15, max(nodeHeights(calTree2))), 
              lwd = 3, 
              width = 2, 
              quat.rm = TRUE, 
              root.edge = TRUE)
dev.off()
```

Running this line will result in a new folder `4.Timetree`, including the different time-calibrated phylogenies obtained (if any) and associated secondary calibrations used in the analyses. The resulting time-calibrated tree is presented in \@ref(fig:timecaltree).


## Advanced methods with phruta 


### Curating taxonomic names

You can use `taxonomy.retrieve()`, a function implemented inside `sq.curate()` in `phruta` to curate species names regardless of the kingdom. For instance, the block of code below will curate taxonomic names using the gbif taxonomic backbone. Note that the `kingdom` argument in `taxonomy.retrieve()` can be set to `NULL`, meaning that there wont be indication on the kingdom when performing taxonomic searches.


```{r message=FALSE, warning=FALSE}
phruta:::taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
                  "Phoca_largha", "PREDICTED:_Phoca" ,
                  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
                  database='gbif', kingdom=NULL)
```

However, `gbif` is efficient for retrieving accurate taxonomy when we provide details on the `kingdom`. Given that all the species we're interested in are animals, we could just use the following block of code to curate taxonomic names.

```{r message=FALSE, warning=FALSE}
phruta:::taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
                  "Phoca_largha", "PREDICTED:_Phoca" ,
                  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
                  database='gbif', kingdom='animals')
```

Depending on your sampling, you could also do the same for plants by using `plants` in thr `kingdom` argument instead of `animals`. Now, what if we were interested in following other databases to retrieve taxonomic information for the species in our database? The latest version of `phruta` allow users to select the desired database. The databases follow the `taxize::classification()` function. Options are: `ncbi`, `itis`, `eol`, `tropicos`, `nbn`, `worms`, `natserv`, `bold`, `wiki`, and `pow`. Please select only one. Note that the `gbif` option in `taxize::classification()` is replaced by the internal `gbif` in `phruta`.

Now, let's assume that we were interested in curating our database using `itis`:

```{r eval=FALSE, message=FALSE, warning=FALSE}
phruta:::taxonomy.retrieve(species_names=c("Felis_catus", "PREDICTED:_Vulpes",
                  "Phoca_largha", "PREDICTED:_Phoca" ,
                  "PREDICTED:_Manis" , "Felis_silvestris" , "Felis_nigripes"),
                  database='itis')
```


### Creating taxonomic constraints in `phruta` <a name="paragraph1"></a>

Users sometimes need to generate tree constrains. `phruta` can automatically generate trees in accordance to taxonomy and a backbone topology. More complex tree constraints can be generated other software including [`TACT: Taxonomic Addition for Complete Trees`](https://github.com/jonchang/tact). For `phruta`, we divide constraint trees into two classes: (1) ingroup+outgroup and (2) particular clades. 

#### ingroup + outgroup constrains

[This section needs more work]

In this constraint type, `phruta` will create monophyletic groups using `tree.constraint()` for each of the taxonomic groups in the database (for selected target columns). Users will need to provide a path to the `1.Taxonomy.csv` file created using the `sq.curate()` function. Finally, `tree.constraint()` will generate tree with the same topology provided in the `Topology` argument. The user will provide the species names of the outgroup taxa as a vector of string that should fully match the names in the taxonomy file.

```{r eval=FALSE}
tree.constraint(
                taxonomy_folder = "1.CuratedSequences",
                targetColumns = c("kingdom", "phylum", "class", "order", 
                                  "family", "genus", "species_names"),
                Topology = "((ingroup), outgroup);",
                outgroup = outgroup$species_names[2]
 )
```

#### Constrains on particular clades

In this constraint type, ``tree.constraint()`` will create a constraint tree for particular clades. Note that the key aspect here is the `Topology` argument. It is a newick tree. For instance, let's assume that we only need to create a tree constraining the monophyly within two genera and their sister relationships:

```{r eval=FALSE}
tree.constraint( taxonomy_folder = "1.CuratedSequences",
                 targetColumns = c("kingdom", "phylum", "class", 
                                   "order", "family", "genus", "species_names"),
                 Topology = "((Callipepla), (Polyplectron));"
 )
```


### Running PartitionFinder in `phruta`

With the current version of `phruta`, users are able to run `PartitionFinder` v1 within `R`. For this, users should provide the name of the folder where the alignments are stored, a particular pattern in the file names (`Masked_` in our case), and which models will be run in `PartitionFinder`. This function will download `PartitionFinder`, generate the input files, and run it all within R. The output files will be in a new folder within the working directory.

```{r eval=FALSE}
sq.partitionfinderv1(folderAlignments = "2.Alignments",
                    FilePatterns = "Masked_",
                    models = "all"
 )
```

Unfortunately, the output files are not integrated with the current `phruta` pipeline. This will be part of a new release. However, users can still perform gene-based partitioned analyses within `RAxML` or can use PartitionFinder's output files to inform their own analyses outside `phruta`.

### Partitioned analyses in RAxML

Users can now run partitioned analyses in `RAxML` within `phruta`. This approach is implemented by setting the `partitioned` argument in `tree.raxml` to `TRUE`. For now, partitions are based on the genes are being analyzed. The same model is used to analyze each partition. More details on partitioned analyses can be customized by passing arguments in `ips::raxml`.

```{r}
tree.raxml(folder = "2.Alignments", FilePatterns = "Masked_",
           raxml_exec = "raxmlHPC", Bootstrap = 100,
           outgroup = paste(outgroup$species_names, collapse = ","),
           partitioned = TRUE
)
```

### Identifying rogue taxa

`phruta` can help users run `RogueNaRok` implemented in the `Rogue` R package. Users can then examine whether rogue taxa should be excluded from the analyses. `tree.roguetaxa()` uses the bootstrap trees generated using the `tree.raxml()` function along with the associated best tree to identify rogue taxa.

```{r message=FALSE, warning=FALSE}
tree.roguetaxa(folder = "3.Phylogeny")
```




Reproducibility with phruta Users can choose to share the script they used to run the analyses (e.g. assemble their molecular dataset) and the associated workspace.

## Performance

```{=html}
<!--
# References
\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.2in}
\setlength{\parskip}{8pt}
\vspace*{-0.2in}
\noindent
-->
```
<http://jboyd.net/Taxo/Odontophoridae.pdf>

Hosner, P.A., E.L. Braun, and R.T. Kimball (2015a), Land connectivity changes and global cooling shaped the colonization history and diversification of New World quail (Aves: Galliformes: Odontophoridae), J. Biogeogr. 42, 1883-1895.

Crowe, T.M., R.C.K. Bowie, P. Bloomer, T.G. Mandiwana, T.A.J. Hedderson, E. Randi, S. Pereira, and J. Wakeling (2006a), Phylogenetics, biogeography and classification of, and character evolution in, gamebirds (Aves: Galliformes): Effects of character exclusion, data partitioning and missing data, Cladistics 22, 495-532.

Crowe, T.M., P. Bloomer, E. Randi, V. Lucchini, R. Kimball, E. Braun, and J.G. Groth (2006b), Supra-generic cladistics of landfowl (Order Galliformes), Acta Zool. Sinica 52, S358-S361.

Cohen, C., J.L. Wakeling, T.G. Mandiwana-Neudani, E. Sande, C. Dranzoa, T.M. Crowe, and R.C.K. Bowie (2012), Phylogenetic affinities of evolutionarily enigmatic African galliforms: the Stone Partridge Ptilopachus petrosus and Nahan's Francolin Francolinus nahani, and support for their sister relationship with New World quails, Ibis 154, 768-780.

\newpage

```{r quail, include=TRUE, fig.cap=c("Quail placeholder. Phyto by Brent Myers"), echo=FALSE}
knitr::include_graphics("./figs/Quail.jpg")
```


\newpage

```{r alnraw, include=TRUE, fig.cap=c("Raw alignments for gene regions sampled in more than 20% of the species in GenBank"), echo=FALSE}
knitr::include_graphics("./figs/UF.Raw.pdf")
```


\newpage
```{r alncur, include=TRUE, fig.cap=c("Curated alignments for gene regions sampled in more than 20% of the species in GenBank"), echo=FALSE}
knitr::include_graphics("./figs/UF.Cur.pdf")
```

\newpage

```{r raxmlphylo, include=TRUE, fig.cap=c("RAxML phylo"), echo=FALSE}
knitr::include_graphics("./figs/raxml_ingroup.pdf")
```

\newpage


```{r timecaltree, include=TRUE, fig.cap=c("Time-calibrated phylogeny phylo"), echo=FALSE}
knitr::include_graphics("./figs/phylo_ingroup.pdf")
```


\newpage

```{r topGenes, echo=FALSE}
kable(head(gs.seqs), caption = "Top six genes sampled in GenBank  for species in Odontophoridae and Polyplectron.", format = "latex") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```

\newpage

```{r AccN, echo=FALSE}
row.names(acc.table) <- NULL
kable(acc.table[,-2], caption = 'Summary of potential accession numbers for the species in Odontophoridae, our ingroup, and Polyplectron, outgroup genus. This list of sequences has not been curated yet.', format = "latex") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```

\newpage

```{r tw, echo = FALSE}
kable(sqs.curated$AccessionTable, caption = "Accession numbers for the retrieved sequences. This dataset has been curated.", format = "latex") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```

\newpage

```{r tw2, echo = FALSE}
kable(sqs.curated$Taxonomy, caption = "Taxonomic information for the retrieved species", format = "latex") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```

\newpage

```{r tw3, echo = FALSE}
kable(sqs.curated$Taxonomy.Sampling, caption = "Taxonomic sampling across gene regions", format = "latex") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```

\newpage

```{r include=FALSE}
rt <- read.csv("3.1.RogueTaxa/RogueTaxa.csv")[,-1]

```


```{r rogue, echo = FALSE}
kable(rt, caption = "Results of RogueNaRock", format = "latex") %>%
  kable_styling(latex_options = c("hold_position", "repeat_header"))
```
\newpage


```{r include=FALSE}
unlink(c("0.Sequences", 
         "1.CuratedSequences", 
         "2.Alignments", 
         "2.1.PartitionFinderv1",
         "3.Phylogeny", 
         "3.1.RogueTaxa",
         "3.2.Phylogeny.constraint",
         "4.Timetree"), 
       recursive = TRUE)
```



